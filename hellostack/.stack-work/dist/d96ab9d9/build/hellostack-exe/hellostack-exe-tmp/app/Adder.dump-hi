
==================== FINAL INTERFACE ====================
2016-01-10 02:33:43.5663668 UTC

interface main@main:Adder 7102
  interface hash: 281f0e1c097dddb3b788ca394dfee31b
  ABI hash: 90974506101aeb86153265b3cc027eb7
  export-list hash: bd343f1af4b74f30f3c85e555a698e0b
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: bd4988337968f447c8105e933c7b6aad
  sig of: Nothing
  used TH splices: False
  where
exports:
  Adder.AdderF{Adder.Add Adder.Clear Adder.Total}
module dependencies:
package dependencies: base-4.8.1.0* ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0
orphans: base-4.8.1.0:GHC.Base base-4.8.1.0:GHC.Float
family instance modules: base-4.8.1.0:Control.Applicative
                         base-4.8.1.0:Data.Either base-4.8.1.0:Data.Monoid
                         base-4.8.1.0:Data.Type.Equality base-4.8.1.0:GHC.Generics
import  -/  base-4.8.1.0:GHC.Base a4939789b2cfd60b36ed163e56a623cd
import  -/  base-4.8.1.0:GHC.Show b8c65ca3124f92a166c9f05120382442
import  -/  base-4.8.1.0:Prelude 518f762991bc287d78f21a73c974da1f
e6795d042ba5706c10f18f89639a9d2b
  $fFunctorAdderF :: GHC.Base.Functor Adder.AdderF
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Adder.AdderF
                  Adder.$fFunctorAdderF_$cfmap
                  Adder.$fFunctorAdderF_$c<$ -}
e6795d042ba5706c10f18f89639a9d2b
  $fFunctorAdderF_$c<$ :: a -> Adder.AdderF b -> Adder.AdderF a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b eta :: a eta1 :: Adder.AdderF b ->
                 case eta1 of wild {
                   Adder.Add n k -> Adder.Add @ a n eta
                   Adder.Clear k -> Adder.Clear @ a eta
                   Adder.Total g
                   -> Adder.Total @ a (\ x :: GHC.Types.Int -> eta) }) -}
e6795d042ba5706c10f18f89639a9d2b
  $fFunctorAdderF_$cfmap ::
    (a -> b) -> Adder.AdderF a -> Adder.AdderF b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U>,
     Unfolding: (\ @ a @ b f :: a -> b ds :: Adder.AdderF a ->
                 case ds of wild {
                   Adder.Add n k -> Adder.Add @ b n (f k)
                   Adder.Clear k -> Adder.Clear @ b (f k)
                   Adder.Total g
                   -> Adder.Total @ b (GHC.Base.. @ a @ b @ GHC.Types.Int f g) }) -}
e6795d042ba5706c10f18f89639a9d2b
  $fShowAdderF :: GHC.Show.Show k => GHC.Show.Show (Adder.AdderF k)
  DFunId[0]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(A,C(U),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ k $dShow :: GHC.Show.Show k.
                  @ (Adder.AdderF k)
                  (Adder.$fShowAdderF_$cshowsPrec @ k $dShow)
                  (Adder.$fShowAdderF_$cshow @ k $dShow)
                  (Adder.$fShowAdderF_$cshowList @ k $dShow) -}
d623c2e3a54774e1cbf2a84f913e6f55
  $fShowAdderF1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0) -}
e6795d042ba5706c10f18f89639a9d2b
  $fShowAdderF_$cshow ::
    GHC.Show.Show k => Adder.AdderF k -> GHC.Base.String
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(A,1*C1(U),A)><S,1*U>,
     Unfolding: (\ @ k $dShow :: GHC.Show.Show k ds :: Adder.AdderF k ->
                 case ds of wild {
                   Adder.Add n k1
                   -> GHC.CString.unpackAppendCString#
                        " Add "#
                        (case n of ww2 { GHC.Types.I# ww3 ->
                         case GHC.Show.$wshowSignedInt
                                0
                                ww3
                                (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                         GHC.Base.++
                           @ GHC.Types.Char
                           (GHC.Types.: @ GHC.Types.Char ww5 ww6)
                           (GHC.Show.show @ k $dShow k1) } })
                   Adder.Clear k1
                   -> GHC.CString.unpackAppendCString#
                        " Clear "#
                        (GHC.Show.show @ k $dShow k1)
                   Adder.Total g
                   -> GHC.CString.unpackAppendCString#
                        " Total "#
                        (GHC.Show.show @ k $dShow (g Adder.$fShowAdderF1)) }) -}
e6795d042ba5706c10f18f89639a9d2b
  $fShowAdderF_$cshowList ::
    GHC.Show.Show k => [Adder.AdderF k] -> GHC.Show.ShowS
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U(A,C(U),A)><S,1*U><L,U>,
     Unfolding: (\ @ k
                   $dShow :: GHC.Show.Show k
                   ls :: [Adder.AdderF k]
                   s :: GHC.Base.String ->
                 GHC.Show.showList__
                   @ (Adder.AdderF k)
                   (\ x :: Adder.AdderF k s1 :: GHC.Base.String[OneShot] ->
                    GHC.Base.++
                      @ GHC.Types.Char
                      (Adder.$fShowAdderF_$cshow @ k $dShow x)
                      s1)
                   ls
                   s) -}
e6795d042ba5706c10f18f89639a9d2b
  $fShowAdderF_$cshowsPrec ::
    GHC.Show.Show k =>
    GHC.Types.Int -> Adder.AdderF k -> GHC.Show.ShowS
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*U(A,1*C1(U),A)><L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ k
                   $dShow :: GHC.Show.Show k
                   ds :: GHC.Types.Int
                   x :: Adder.AdderF k
                   s :: GHC.Base.String ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      (Adder.$fShowAdderF_$cshow @ k $dShow x))
                   s) -}
e6795d042ba5706c10f18f89639a9d2b
  data AdderF k
    = Add GHC.Types.Int k | Clear k | Total (GHC.Types.Int -> k)
instance GHC.Base.Functor [Adder.AdderF] = Adder.$fFunctorAdderF
instance GHC.Show.Show [Adder.AdderF] = Adder.$fShowAdderF
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

